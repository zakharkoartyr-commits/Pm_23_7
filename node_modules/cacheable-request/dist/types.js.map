{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"AAAA,6CAA6C;AAC7C,kEAAkE;AAClE,mEAAmE;AACnE,kEAAkE;AAClE,kEAAkE;AAClE,0BAA0B;AAkK1B,MAAM,OAAO,YAAa,SAAQ,KAAK;IACtC,YAAY,KAAY;QACvB,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QACrB,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,yBAAyB,CAAC,KAAK,CAAC,CAAC,CAAC;IACxE,CAAC;CACD;AAED,MAAM,OAAO,UAAW,SAAQ,KAAK;IACpC,YAAY,KAAY;QACvB,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QACrB,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,yBAAyB,CAAC,KAAK,CAAC,CAAC,CAAC;IACxE,CAAC;CACD","sourcesContent":["// Type definitions for cacheable-request 6.0\n// Project: https://github.com/lukechilds/cacheable-request#readme\n// Definitions by: BendingBender <https://github.com/BendingBender>\n//                 Paul Melnikow <https://github.com/paulmelnikow>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n/// <reference types=\"node\" />\n\nimport type { Buffer } from \"node:buffer\";\nimport type { EventEmitter } from \"node:events\";\nimport type {\n\tClientRequest,\n\tRequestOptions,\n\trequest,\n\tServerResponse,\n} from \"node:http\";\nimport type { URL } from \"node:url\";\nimport type { CachePolicyObject } from \"http-cache-semantics\";\nimport type ResponseLike from \"responselike\";\n\nexport type RequestFn = typeof request;\nexport type RequestFunction = typeof request;\nexport type CacheResponse = ServerResponse | typeof ResponseLike;\n\nexport type CacheableRequestFunction = (\n\toptions: CacheableOptions,\n\tcallback?: (response: CacheResponse) => void,\n) => Emitter;\n\nexport type CacheableOptions = (Options & RequestOptions) | string | URL;\n\nexport interface Options {\n\t/**\n\t * If the cache should be used. Setting this to `false` will completely bypass the cache for the current request.\n\t * @default true\n\t */\n\tcache?: boolean | undefined;\n\n\t/**\n\t * If set to `true` once a cached resource has expired it is deleted and will have to be re-requested.\n\t *\n\t * If set to `false`, after a cached resource's TTL expires it is kept in the cache and will be revalidated\n\t * on the next request with `If-None-Match`/`If-Modified-Since` headers.\n\t * @default false\n\t */\n\tstrictTtl?: boolean | undefined;\n\n\t/**\n\t * Limits TTL. The `number` represents milliseconds.\n\t * @default undefined\n\t */\n\tmaxTtl?: number | undefined;\n\n\t/**\n\t * When set to `true`, if the DB connection fails we will automatically fallback to a network request.\n\t * DB errors will still be emitted to notify you of the problem even though the request callback may succeed.\n\t * @default false\n\t */\n\tautomaticFailover?: boolean | undefined;\n\n\t/**\n\t * Forces refreshing the cache. If the response could be retrieved from the cache, it will perform a\n\t * new request and override the cache instead.\n\t * @default false\n\t */\n\tforceRefresh?: boolean | undefined;\n\tremoteAddress?: boolean | undefined;\n\n\turl?: string | undefined;\n\n\theaders?: Record<string, string | string[] | undefined>;\n\n\tbody?: Buffer;\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: type\nexport interface CacheValue extends Record<string, any> {\n\turl: string;\n\tstatusCode: number;\n\tbody: Buffer | string;\n\tcachePolicy: CachePolicyObject;\n}\n\nexport interface Emitter extends EventEmitter {\n\taddListener(\n\t\tevent: \"request\",\n\t\tlistener: (request: ClientRequest) => void,\n\t): this;\n\taddListener(\n\t\tevent: \"response\",\n\t\tlistener: (response: CacheResponse) => void,\n\t): this;\n\taddListener(\n\t\tevent: \"error\",\n\t\tlistener: (error: RequestError | CacheError) => void,\n\t): this;\n\ton(event: \"request\", listener: (request: ClientRequest) => void): this;\n\ton(event: \"response\", listener: (response: CacheResponse) => void): this;\n\ton(\n\t\tevent: \"error\",\n\t\tlistener: (error: RequestError | CacheError) => void,\n\t): this;\n\tonce(event: \"request\", listener: (request: ClientRequest) => void): this;\n\tonce(event: \"response\", listener: (response: CacheResponse) => void): this;\n\tonce(\n\t\tevent: \"error\",\n\t\tlistener: (error: RequestError | CacheError) => void,\n\t): this;\n\tprependListener(\n\t\tevent: \"request\",\n\t\tlistener: (request: ClientRequest) => void,\n\t): this;\n\tprependListener(\n\t\tevent: \"response\",\n\t\tlistener: (response: CacheResponse) => void,\n\t): this;\n\tprependListener(\n\t\tevent: \"error\",\n\t\tlistener: (error: RequestError | CacheError) => void,\n\t): this;\n\tprependOnceListener(\n\t\tevent: \"request\",\n\t\tlistener: (request: ClientRequest) => void,\n\t): this;\n\tprependOnceListener(\n\t\tevent: \"response\",\n\t\tlistener: (response: CacheResponse) => void,\n\t): this;\n\tprependOnceListener(\n\t\tevent: \"error\",\n\t\tlistener: (error: RequestError | CacheError) => void,\n\t): this;\n\tremoveListener(\n\t\tevent: \"request\",\n\t\tlistener: (request: ClientRequest) => void,\n\t): this;\n\tremoveListener(\n\t\tevent: \"response\",\n\t\tlistener: (response: CacheResponse) => void,\n\t): this;\n\tremoveListener(\n\t\tevent: \"error\",\n\t\tlistener: (error: RequestError | CacheError) => void,\n\t): this;\n\toff(event: \"request\", listener: (request: ClientRequest) => void): this;\n\toff(event: \"response\", listener: (response: CacheResponse) => void): this;\n\toff(\n\t\tevent: \"error\",\n\t\tlistener: (error: RequestError | CacheError) => void,\n\t): this;\n\tremoveAllListeners(event?: \"request\" | \"response\" | \"error\"): this;\n\tlisteners(event: \"request\"): Array<(request: ClientRequest) => void>;\n\tlisteners(event: \"response\"): Array<(response: CacheResponse) => void>;\n\tlisteners(event: \"error\"): Array<(error: RequestError | CacheError) => void>;\n\trawListeners(event: \"request\"): Array<(request: ClientRequest) => void>;\n\trawListeners(event: \"response\"): Array<(response: CacheResponse) => void>;\n\trawListeners(\n\t\tevent: \"error\",\n\t): Array<(error: RequestError | CacheError) => void>;\n\temit(event: \"request\", request: ClientRequest): boolean;\n\temit(event: \"response\", response: CacheResponse): boolean;\n\temit(event: \"error\", error: RequestError | CacheError): boolean;\n\teventNames(): Array<\"request\" | \"response\" | \"error\">;\n\tlistenerCount(type: \"request\" | \"response\" | \"error\"): number;\n}\n\nexport class RequestError extends Error {\n\tconstructor(error: Error) {\n\t\tsuper(error.message);\n\t\tObject.defineProperties(this, Object.getOwnPropertyDescriptors(error));\n\t}\n}\n\nexport class CacheError extends Error {\n\tconstructor(error: Error) {\n\t\tsuper(error.message);\n\t\tObject.defineProperties(this, Object.getOwnPropertyDescriptors(error));\n\t}\n}\n\nexport interface UrlOption {\n\tpath: string;\n\tpathname?: string;\n\tsearch?: string;\n}\n"]}